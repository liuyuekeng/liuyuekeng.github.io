---
layout: post
title: "about-FP"
date: 2016-09-23 23:35:21
categories: coding
---

# SECTION 0 引言

## 0.0 Why

这段时间陆陆续续看了一些函数式编程相关的书籍和文章，
却一直没有对这部分知识内容进行整理。
比起被动地接收信息，尝试去产出信息可能能够引导自己对只是进行更深入的思考。

加上最近工作中开始启动新项目，在编程风格上可以更灵活的选择，
在真正落地之前还是需要让自己沉淀一下。

## 0.1 How

既然要讨论函数式，没什么比用纯粹的函数式语言作为载体更合适了。
但无论对未接触过学院派语言的人，或是对目前工作的生产环境来说，
Haskell，Lisp之类的纯函数式语言并不是友好的载体。

当然也有《JavaScript函数式编程》这种使用JavaScript作为载体的书籍，
但重点相对倾向了JS本身，对函数式中很多重要概念没有提及。

随着JavaScirpt标准的不断更新，
从这些学院派语言中吸收了许多优点（箭头函数，模式匹配等）。
用JavaScript实现这些函数式的模式渐渐变得不那么拗口了。
所以希望用JavaScript给函数式编程中各概念的对应实现，
再结合生产环境中真实的问题进行说明，展示函数式编程的魅力。

# SECTION 1 纯度

## 1.0 纯函数

回想高中时代的数学课，函数熟悉的形式应该就是 f(x) = y。
其关键在于，给定一个 x ，y都有__唯一确定__的值与之对应，那么 y 就是 x 的函数了。

实际上，编程中纯函数的定义与此是一致的——

__函数 f 在给定参数 x 的情况下，都有唯一对应的 y 作为返回值，那么 f 就是一个纯函数。__

（想要提升格调，可以使用__“引用透明”__一词来描述这种特性）

    // 纯函数（°Д°）ъ！
    var add1 = x => x + 1;
    add1(1)     // 2
    add1(1)     // 2
    
    // 非纯函数
    var a = 1;
    var addWithA = x => x + a;
    addWithA(1)     // 2
    a = 2;
    addWithA(1)     // 3

使用相同的参数调用`add1`总会得到相同的结果，但`addWithA`却不然，
它会随着变量`a`的改变而表现出不同的行为。
因为`addWithA`对变量`a`的依赖，变量`a`的变化对`addWithA`就产生了副作用。
所以我们可以说

__纯函数的输出只依赖于输入的参数。__

Ps. 这里是不可以逆推的，纯函数输出只依赖输入参数，
但是输出只依赖输入参数的函数不一定是纯函数——
假设输入参数中有不纯的函数，那么该函数也就被污染了，成为非纯函数。

在数学上，把函数理解为映射关系是比较经典的思路，但在函数式编程中，我更倾向于另一种解释。
函数可以理解为一个量包含另一个量 y = f(x) —— y 包含 x，而 f 则是x的上下文。
举例来说，`add1`就包含`加一`的上下文，`add1(x)`则是对x的上下文进行求值的过程。
接受上下文这种解释，对后面理解函子等概念会有所帮助。

那么这种只能求值的函数有个卵用呢？good question！

## 1.1 记忆

正如上面的例子，变量给函数引入了时间维度的复杂度——在不同时间进行求值会得到不同的结果。
在Haskell这样纯粹的函数式语言中，甚至是没有__变量__这个东西的。
是什么原因让我们在函数式编程中对纯度如此在意？

记忆！是函数式的一大优势——如果说函数对特定的输入必然有唯一对应的结果——
那么就永远没有必要对函数重复求值。
也就是说`add1(1)`与整数`2`一样，只是一个固定不变的量而已。

在Haskell中，记忆是语言本身的机制维护的，而在JavaScript中，我们也可以手动模拟这个过程。

    // fibonacci with memoize
    var fibonacci = _.memoize( n =>
        (n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2)));
    fibonacci(10)   // 55 函数调用10次
    
    // fibonacci without memoize
    var fibonacci = n => (n < 2 ? n : fibonacci(n - 1) + fibonacci (n - 2));
    fibonacci(10)   // 55 函数调用176次

这里使用了lodash库中的memoize方法，实现了对斐波那契数列第n项的求值。
简单来说，memoize用一个hash，以输入的第一个参数为key，缓存住函数的计算结果。
具体内容见lodash的文档 [lodash docs](https://lodash.com/docs)

可以看到，直接用递归计算斐波那契n项，效率低下，
而当n增大时，差距还会迅速增大（当然不会有人真的这么实现）。

纯函数语言能够从语言层面给我们保证记忆的特性，
既然他们没有变量的存在，在编译时就可以轻松完成这项工作——将函数的计算结果缓存，
JavaScript做不到这一点，所以纯函数给我们带来记忆上的便捷要大打折扣，
但在实现大规模计算的时候，仍可以考虑用记忆的特性进行优化。

## 1.2 单元测试与解耦

__纯函数的输出只依赖于输入的参数。__
显而易见，纯函数对单元测试是非常友好的:)
我们只要丢给他一些参数，就可以翘起腿来等待它返回你期待的结果了。

除了对自动化测试友好，提纯更是一种解耦的方式，让函数把外部的依赖都撇开，专注于自身的逻辑。

假设我们要对下面两个函数进行单元测试

    var add1 = x => x + 1;
    
    var a;
    
    var addWithA = x => x + a;

你就会发现`add1`很容易测试，而`addWithA`对外部的依赖变成了一个棘手的问题，
我们不得不在单元测试代码中引入一个外部变量ㄟ(⊙ω⊙ㄟ)蛤？
那这还能叫做单元测试吗？

这种情况还不算最糟糕的，来看看这个。

    var a = 0;
    
    function b () {
        ...
        a++;
        ...
    }
    
    function c () {
        console.log(a);
        b();
        console.log(a);
    }

当这些依赖互相关联，形成网状结构的时候，噩梦才真正开始，
你永远不知道单元测试该期待什么结果了。
这并不是一个胡编乱造的例子，随便找一个项目的类图看一看，
就会发现现实中依赖的复杂程度远远要比这糟糕得多。

Ps.要对这种网状结构中的节点进行单元测试，只能使用mock之类的方法。
可以理解为使用一些模拟的依赖来切断节点与外界的联系，然后针对单一节点执行单元测试。

对此你可能不以为然，认为`add1`这种理想的情况，只有在少数基础库中会出现，
现实中的逻辑本身就是错综复杂的，躲在象牙塔中的纯函数实际上并无用武之地。

那么让我们来看看angular的依赖注入是怎么一回事儿吧。

    angular.module('a').service('b', function (c, d, e) {
        // use c, d, e here
    });

将依赖以参数的形式传入函数中，如果注入的依赖是纯的，那该函数本身就是纯的了。
听起来有点掩耳盗铃的意思，这么做似乎只是把问题撇给别人而已——
毕竟现实世界中的编程肯定会有“脏”的部分。

函数式编程并不否认“脏”的部分，也不打算消灭他们，
而是试图把这些不纯的部分隔离到最外围，这个过程也被称作“提纯”。
通过这样的方式来消除函数之间的相互联系，达到整个系统解耦的目的。

# SECTION 2 函数

## 2.0 函数与高阶函数

在JavaScript中，函数能够出现在任何值能够出现的位置。
也就是会所函数能够和值一样，作为参数被传递，或是作为结果被返回。
这也就是所谓高阶函数的概念——

__高阶函数接受函数作为参数或者将函数用作返回值的函数__

boring~作为一个JavaScript的程序员，这显然不是什么新奇的事情，毕竟我们整天都在使用高阶函数。

使用`setTimeout(function ,millisec)`和`[].sort(function)`时，
我们把需要延迟执行的函数与用于比较的函数以参数的形式传入。

把函数当作返回值的情况似乎少见些，往前翻到`1.1 记忆`这一节中，
`_.memoize`方法的返回值就是一个函数，一个带有记忆特性的函数。
后面我们还会见到更多这样的函数，而这些函数正是函数式编程的魅力所在。

## 2.1 柯理函数

    var addThree = (a, b, c) => (a + b + c);

这是一个多元函数（准确来说是二元函数），接收两个参数然后返回他们的加和。

    var addThreeCurry = a => b => c => (a + b + c);

这是一个。。。啥？(＠\_＠;)?
没错！这就是一个传说中的柯里函数！
鉴于箭头函数还算是ES6里面的新特性，让我们先把它换成熟悉的形式以便于理解吧。
上面的代码其实等同于

    var addThreeCurry = function (a) {
        retrun function (b) {
            return function (c) {
                return a + b + c;
            }
        }
    }

__柯里函数与常见的的多参函数的不同之处在于，柯里函数不一次性取完所有函数，
而是在每次调用的时候只取一个参数，并返回一个一元函数来取下一个参数。__

自从有了箭头函数，我们用JavaScript书写柯理函数便捷了许多，
个人感觉这是JavaScript向函数式语言中借鉴的最实用的语法了。

既然我们已经知道柯里函数是个什么东西了，
__那么把多元函数变成柯里函数的过程，就叫做柯理化咯。__
让我们再次隆重请出函数式的好朋友lodash同学！（°Д°）ъ

    var addThreeCurry = _.curry(addThree);
    addThreeCurry(1)(2)(3);  // 6

非常便捷地将一个多元函数变成了一个柯里函数。
简单来说就是维护一个参数列表，直到接收的参数数量达到addThree.length，再执行运算。

Ps.实际上lodash生成的并不是一个严格的柯里函数，
`addCurry(1, 2)(3)`这样调用也是可以的，还可以手动指定参数个数，具体见lodash文档 [curry](https://lodash.com/docs/4.16.1#curry)

我们为什么要如此大费周章，把多元函数变成柯里函数呢？
除了调用需要多写几个括号之外，有两个明显变化。
一是固定了函数的参数个数，只有参数数量足够时函数才会真正被执行。

    addThree(1, 2);         // NaN
    addThreeCurry(1)(2);    // function

二是函数调用从一个一次性的计算变成了一个持续的过程，
而过程中的每一个中间状态都是可以利用的。

    addTwoWith1 = addThreeCurry(1);
    addTwoWith1(2)(3);      // 6
    addTwoWith1(4)(5);      // 10

第一点对于经常利用JavaScript不定长参数便利的人来说，可能更像是一种约束，
也许现在还看不出来，但第二点则是柯里函数最大的优势。
它如此重要以至于在Haskell中被认为是理所当然的——Haskell中__所有函数__都是柯里函数
而无括号调用的语法也使得在Haskell中使用柯里函数更加便捷。


