---
layout: post
title:  "《白帽子讲web安全》"
date:   2015-11-16 23:12:00
categories: 书评
---

##安全意识

对工程师来说，安全意识是很重要的，但在工作中往往是最被忽略的。很多时候都是一种侥幸心理，“不会有人来搞我的”，然后就被搞死了。

又有人会觉得，做个转码就好啦，做个加密就好啦，做个编码就好啦等等。由于不了解，低估了入侵的手段。

前者是态度不对，后者是姿势水平太低，而我两种都有。我记得刚工作的时候就写下一个XSS注入点，不久便接到公司安全部门的一张安全工单，此时才意识到自己完全没有考虑过安全的问题。

##认识攻击才能懂得防御

如果对XSS，CSRF，SQL注入等不熟悉的话，（特别是XSS），防御就无从谈起。如果对加密算法不了解的话，也就不懂得如何正确地会用它们。这么说来，开发懂得最基本的heck知识是非常有必要的。

这本书关于web安全的方方面面基本都覆盖到了，看完对各种攻击手段至少都会有一个概念。我所认识的人中，多数连这个概念都没有，防御也就无从谈起。

书的行文一般，但条理还是比较清晰的，也能够从比较高的角度来看待安全问题。除了原理介绍，脚本代码，还有如何构建防御体系的建议，对于像我这样的安全小白来说，收获非常大。

******

下面是一些零散的笔记，没仔细整理。

##客户端脚本安全

####XSS（跨站脚本攻击）
如果别的网站的代码能跑到你的页面下执行，那么他基本什么都能干了。

说白了XSS漏洞的形成无非就是被插入了恶意的代码。
攻击者的想象力确实令人佩服，url，input，css等等任何地方都能藏代码，因此形成的原因复杂多样。

但最终解决的方案无非是转码，应该说是在*正确*的地方使用*正确*的转码。

书里把XSS攻击分成下面三类

* 反射型XSS

在URL参数中藏代码，一般需要让用户来点击一个藏着恶意代码的链接。
当链接中的恶意代码被渲染到页面中，给执行的时候，攻击者就达到了目的。

* 存储型XSS

恶意代码就藏在页面中，用户正常访问的时候就可能执行这一段代码。
比如在上传博文的时候夹上脚本。

* DOM Based XSS

修改DOM节点，增加事件等等来执行恶意脚本，其实感觉算是反射型的一种吧。

******

一旦脚本顺利被页面执行，就可以做好多危险的事情。

* 可以用来拿cookie做cookie劫持，绕过登陆环节
* 构造POST，GET请求，在用户不知道的情况下做各种操作。
    模拟用户进行增删改查，盗取用户信息内容，发到攻击者的服务器
* 跳弹窗钓鱼
* 判断用户浏览器特性，扫描用户安装了哪些插件。
    利用浏览器与插件的漏洞完成后续攻击
* 甚至形成蠕虫传播。

一般来说，用户输入都会经过转义和校验。
但正如前面所说，防御XSS并不是简单粗暴的转义就能够完事儿的
因为XSS是跟环境语义紧密相关的，可以说没有统一的解决方案。
不同的位置需要不同的策略对待，否则这些校验往往会被攻击者绕过。

攻击者会利用编码绕过转义，
利用事件，哈希，外部脚本绕过长度限制，
利用base标签进行资源劫持，
利用window.name跨页面传递数据，还有像flash之类危险的东西。。。

******

* 设置保存登陆信息的cookie使用HTTPOnly，这样JS就不能获取到这个cookie了。
    这实际上只能防御cookie劫持相关的攻击。
* 服务端与前端进行相同的白名单输入检查，当然输入检查同样不能解决所有问题。
    因为用户提交数据的时候还没到HTML渲染这一步，所以XSS过滤在这个时候并不能理解语境，
    有可能误杀一些正常的输入
* 输出检查就是在把用户数据输出到HTML页面的时候，进行编码，防止数据被当成代码执行。
编码必须被正确使用，否则没有意义。

输出到HTML标签中时使用HtmlEncode，防止被插入script或者图片等能产生脚本执行的东西，
输出到HTML属性中的时候也需要做同样的事情。

输出到script标签中需要进行javascriptEncode，并且保证变量输出在引号中。
被encode的变量没办法跳出引号的区域，保证安全性。
（其实我一直反感用PHP生成JS代码，最好能不用就不用，听起来就容易出问题）

在css中输出，有cssEncode的库可以将css输入编码成十六进制。
但和上一条一样，最好就不要让用户控制css代码。

在地址栏中输出当然是要使用urlEncode啦，但往往被忽视的是变量输入是一整个url的情况。
这时候协议头不能用urlEncode，有的攻击者会利用一些伪协议来执行代码
（javascript，vbscript，dataURI等）这时候需要先检查是不是http头，没有就强制加上，防御伪协议XSS攻击

富文本则需要使用*白名单*，只允许a，img，div之类安全的标签，禁用事件，禁用CSS

DOM Based XSS是一种比较特殊的情况，大概也是把它单独拆出来的原因了。
它是通过JS输出数据到HTML中，而JS代码是依赖用户数据生成，这时候需要两层编码。
首先变量输入到js代码中需要执行一次javascriptEncode，
而js往HTML中写入的时候要再做一次HTMLEncode。才能保证写入的安全。

XSS最烦的地方就是能产生漏洞的地方太tm多了，一旦有一个点没做好，就前功尽弃。

####CSRF跨站点请求伪造

诱导用户去访问一个页面，这时候页面发出一个请求，就以用户身份在第三方站点执行了一个操作。

CSRF成功一个原因是用户的cookie被发送了，这与浏览器的cookie策略有关。
还有一个特殊的HTTP头，P3P，可以让浏览器不再拦截第三方cookie发送。

防御CSRF可以用下面的各种方式

* 验证码，PM不会喜欢这种手段的，确实体验也不好
* refer检查，有的页面没有refer，比如HTTPS跳到HTTP的请求，或各种奇怪的设置
* Anti CSRF Token，生成一个随机Toke，放在session中，表单提交的时候也要加上token。
    服务器接到表单提交的时候，验证token与session中的token是否一致。
    这样的方式重点在于保证token不会被泄露。
    首先token最好藏在表单中，url中容易通过refer等渠道泄露，
    其次如果站点上有其他XSS漏洞，那么token就形同虚设了

####点击劫持
点击劫持给我的感觉像是一种耍杂技式的攻击方式，不得不说很有创意。

* 透明iframe，用透明iframe盖在最上层，通过调整iframe的位置，诱导用户不知不觉完成一些操作
* flash点击劫持，通过flash小游戏之类的形式，诱导用户进行复杂的操作，
* 图片覆盖攻击，图片可以伪装成页面的一部分，链接，按钮，logo等。
    如果img标签可以被设定style属性，就有可能出现这种威胁
* 拖拽劫持，拖拽事件是一个相对较新的事件，他相比点击更加危险，
    因为拖拽事件有的是可以跨窗口的。

有一个HTTP头叫X-Frame-Option，可以限制frame的加载，可以进行防御。

####HTML5安全

新标签和新设计的引入带来了新的问题，同时也带来了新的解决方案

先说问题

* 比如XSS过滤的时候如果是用的黑名单，有可能不会覆盖到新增标签如video，audio之类的造成跨站脚本执行。
* 在比如通过canvas可以操作图片对象，有可能被用来破解验证码。
* 跨域资源请求Access-Control-Allow-Origin。如果设成\*，那就真是日了狗了。
    我确实在公司见过把这个头设成\*的，善意提醒后人家也说改不了，不知道有多少个源在用。。。
* postMessage跨窗口传递消息，这是一个突破沙盒的东西，显而易见很容易出问题，
    用的时候要万分小心。必要时候验证url，并对接受的消息做安全检查
* web storage是一个藏代码的新地方，需要注意

新的解决方案

* iframe可以设置allow-script属性限制脚本的执行，算是一件好事
* a标签可以设置noreferrer属性，跳转不带refer

##注入

我以前一直以为注入这种东西，只要做好转码完全没有问题，
但实际上转码并不能很好的防御注入，算是长见识了。

#####SQL注入都是怎么做的？

攻击者寻找注入的点，也就是所谓的“盲注”，一般是通过构造简单的条件语句来判断漏洞是否存在。
比如加上` and 1=1`和` and 1=2`页面展示如果不一样就可以知道注入成功了。

当简单的条件判断无法看出异常的时候，另一种方式叫做timimg attack，
利用像MYSQL中的BENCHMARK这种性能测试函数多次执行，让返回结果的时间比平常的长。

通过这些方式，可以逐个遍历判断数据库名，用户名，数据库版本甚至猜密码等。
然后如果当前数据库用户还有写权限，那就等着被拖库吧。
利用读写文件的操作，攻击者可以获取信息，甚至导出webshell给你开个后门。

除了使用webshell，还有一种是利用用户自定义函数来执行系统命令。
先把库文件上传到数据库访问路径下，然后创建自定义函数，就可以执行系统命令了，root指日可待。

与用户自定义函数类似的还有存储过程，这是数据库内置的一些功能，可以执行系统命令。

另外还有一些利用字符集不同，绕过转义；利用超长截断的属性插入同名数据等奇怪的技巧。

#####SQL注入怎么防御？

escape是不够的，因为攻击者构造注入代码的时候，往往不需要使用这些字符，
所以并不能因为做了escape就觉得可以放心了

最靠谱的方式就是使用预编译语句了，变量用？表示，SQL的结构不会被改变。

另一种方式是使用存储过程，先将SQL语句定义在数据库中使用
（尽量使用静态SQL，动态SQL仍然会存在注入）

数据检查，根据语义过滤输入（邮箱，日期，数字等）

使用安全函数做过滤，编码虽然有可能被绕过，但还是有必要的。

权限问题，这个是最重要的一点，web应用不要使用root账户，
不要使用高权限用户连数据库，不要给自定义函数，操作本地文件的权限。
遵循最小权限原则，即使被注入了也能一定程度上限制影响范围。

#####XML注入

如果不做输入检查，可能被插入而已数据，只要把语言本身的保留字转义就可以，比较简单。

#####代码注入

这种基本属于自己作死才会出现的情况，通常是使用了不安全的函数，比如js中的eval函数。
不要使用可以执行命令的函数，也不要在脚本中动态include远程文件。

#####CRLF注入

CR是\r，LF是\n，换行符的插入往往会改变语义。
比如按换行分割的日志，有可能被插入换行符导致log注入
或者在HTTP头中被插入了换行符（HTTP头就是用\r\n来分割的），可以添加一些安全相关的头，
或者注入两个换行提前跳到body等等。

一般用户控制的并且会写到HTTP头里的就是cookie啦，在往HTTP头里面写东西要过滤换行符。

##文件上传

攻击者上传了可执行文件到web容器里，然后被执行了，也就是所谓的webshell。

文件上传本来是一个正常的功能，但有时候安全检查做的不到位，就会扑街。这往往不是我们自己代码的问题。

限制文件上传的策略一般就是文件后缀检查，或更严格一点的文件头检查。

首先是方法本身并不可靠，后缀名并不能与文件真正的类型画上等号，文件头也有可能伪造。
其次是策略有可能不可靠，尽量应该使用白名单而不是黑名单来做验证。
最后是第三方库中的文件上传代码很可能包含漏洞，并不能完全信任。

有些服务器的配置也造成文件被解析的情况。

* apache对文件名解析是从后往前进项，直到遇到能识别的类型为止。
    所以a.php.rea会被认为是php类型，而上传的时候可能只检查了rar后缀。导致脚本被解析
* 文件名截断0x00字符，分号等，IIS6遇到`path/xx.asp;abc.jpg`会丢掉abc.jpg不管导致asp脚本执行
* PUT方法开启
* PHP递归路径查询有一个bug，可能导致脚本解析。可以通过cgi.fix_pathinfo为0阻止

这些乱起八早的方法，还有乱七八糟的服务器bug我们不可能都知道。
所以，最重要的点不是限制非法文件的上传，而是即使文件被上传了，也不会被web容器解析执行。
这样才能保证攻击不能生效。

* 文件上传目录分开，或者独立存储，可以优化性能，也可以杜绝脚本执行
* 文件判断类型使用白名单，对图片压缩或使用resize破坏图片中可能包含的代码
* 随机改写文件名和路径，这有几个好处。
    一是用户可以上传，但不能访问；二是根据命名做的手脚会失效；三是不能上传某些特定的配置文件了
* 单独设置文件服务器域名

##加密

使用加密并不代表安全，只有了解各个加密算法的特性才能正确地使用它们。

比如RC4在IV较小的情况下容易被爆破，MD5做签名的时候要把加密key放在后边等等。
选择更安全的算法，用在更合理的地方。
