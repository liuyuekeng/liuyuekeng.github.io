---
layout: post
title:  "关于token"
date:   2015-12-10 23:59:00
categories: web
---

##token是啥

token这个概念其实很早就出现了。《三国演义》中曹操打汉中的时候就曾定下“鸡肋”这一著名的口令。
潜入军营但不知道口令就会被抓起来干掉。

如今我们在网络中使用的token也是一样的道理。
服务器给用户一个口令，这个口令只有服务器和用户知道。
有坏人想要冒充用户的时候，由于没有正确的口令，就会被判定为非法请求。

##CSRF

跨站请求伪造，是一种非常常见的攻击手段，
其本质是请求的所有参数都可以被构造。
token正是解决这个问题的最常用&有效的方法。

假设你去取快递，快递小哥通过姓名和电话来确认交货。
这时候有个坏人拿到了你的姓名和电话（这并不是什么难事），要来冒领你的快递，你的快递就被领走了。
原因就是所有请求的参数（这里是姓名与电话）都可以被构造。
但如果你与快递小哥事先约定了一个暗号（更准确地说是快递小哥与每个人约定了不同的暗号），
那坏人由于没有接头暗号，就露馅了。

通常用户连接服务器的时候，由服务器分配一个token给用户。
用户在进行操作的时候，需要将token放在操作请求中一起带给服务器，通过这样来验证用户。

##使用token有什么要求

token第一个要求就是不能容易被猜到，身为一个暗号，总不好太简单吧。
token的第二个要求是要有时效性，比如持续5分钟或者每次使用就作废。

做到这两点，坏人不能轻易试出你的token，而即使从某种手段获得了，也不能一直生效。

##token放在哪儿

token是一个敏感信息，就像曹操不会把口令贴在军营门口，
你也不应该把token放在类似url参数这种显眼易得的地方。
那token究竟放在哪里呢？

在前端，cookie是一个好地方，请求返回的时候自然就会带上cookie，前端对此没有感知。

在服务端，事情就变得复杂起来。
如果你只有一台机器，大可直接放到session中，或者自己简单实现一个服务端文件存储。
但如果你处在一个分布式的系统，session/文件同步就成了令人头疼的问题。
![session problem](/images/about_token1.png)

解决这个问题有两种思路。

第一种webserver的层面解决，根据用户id哈希做负载均衡。
从而保证上图的用户所有请求始终落在A机器上，无需关心文件同步的问题。

第二中是把session单独抽离出来做一个服务。如果只是token这种简单的需求，一个redis就可以满足。
或者公司一般会有这种基础的服务。
![session service](/images/about_token2.png)

##不要存储

为了一个token搞这么多东西，似乎很不值当，我们能不能有更方便的办法。

####时间戳+id

最常用的一种模式

    hash(id + excTime + secKey)

当用户访问页面的时候，使用用户id，超时时间戳和秘钥的哈希签名作为token分发给用户。

当用户返回token的时候，把超时时间一起返回。
服务器校验是否超时，然后再算一次哈希签名，验证数据有效性。

可以看到，整个过程中没有使用存储。利用秘钥保证token难以猜测，利用过期时间限制token的时效性。
保证每个用户每段时间内的token是不同的。
想要修改时间戳则会因为不知道secKey而无法构造合法签名。

回到快递小哥的例子，每天派那么多快递，如果要记住这么多不同的暗号，必然要拿一个小本本。
但小哥不想这么干，他使用一个签名算法用你的名字和取件日期做了一个暗号给你。
当你来找他的时候，他只要验算一下你的暗号是否合法就可以了。

实际上这已经和传统意义上的口令不是一回事儿了。
传统的口令必定双方都要保存一份，通过对比口令来确认授权。
而这种签名的方式则是依靠签名秘钥的保密来保证安全，也就是快递小哥心算的那个方法。
服务端不保存口令，但别人也无法伪造签名。

##还能干嘛

我们可以看到上面这个简单的例子，包含了三个不可缺少的部分，
我们需要id来保证用户的相互独立，excTime来保证token随时间变动，secKey来保证不能伪造/猜测。
而实际上我们可以用同样的方法来做一些其他事情。

想象一个电商的订单的系统，用户的每个操作需要按照特定的流程来进行。
一般会用session来保存用户状态，这里就涉及到session维护的问题。
然而把上面的方法改变一下，就可以免掉session维护的麻烦。

我们只要把加上一个stateCode进行签名。
每次用户请求，我们验证状态是否合法，在操作完成后我们把新状态的签名再下发给用户。
这样子就能省去对用户状态的存储，同时也能保证操作的流程合法。

##总结

实际上整个解决问题的思想就是。
把数据存储在客户端，服务端不进行保存，并通过签名来保证客户端的数据不被篡改。

这样做的好处，就是减少IO，我们不再需要存储token，在验证的时候也不需要再读取本地数据。
