---
layout: post
title: "当我们聊性能的时候都聊些什么"
date: 2016-06-27 16:23:08
categories: coding
---

工作中遇到许多关于性能的问题，在这里统一记录一下

### 关于HTTPS

都知道HTTPS慢，但想要知道为什么慢，慢在哪里，到底多慢却比较麻烦了。
首先HTTPS其实和HTTP一样，是建立在TCP上的，只不过是多了一个SSL的流程。
也就是说，一个HTTP请求建立需要TCP握手三次，但HTTPS在TCP握完之后还需要再进行SSL的握手。
而密钥协商之后数据传输都需要增加一个加密解密的流程。
先来一个科普贴 [阮博士的科普贴](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

那么很明显，HTTPS的延迟主要跟两个方面有关。密钥交换耗时，除了客户端和服务器之间网络延迟，还包括了证书检查；
签名校验延迟，这是CPU的延迟。网络状况，计算性能，加密算法等等细节都会造成不同的影响。
更多的细节见传送门~[百度同学的博客](http://blog.csdn.net/luocn99/article/details/39777707)，
看来看去最靠谱的就是这篇文章了。

但这只是在完整SSL握手的情况下，实际上SSL会话是可以重用的。
传送门~[重用Session](http://www.jdon.com/performance/speeding-up-https-with-session-resumption.html)
能够省掉证书交换的几个RTT，收益非常可观。

另外，除了传统的HTTPS协议，还可以参考其他[更快的协议](http://www.infoq.com/cn/news/2015/02/https-spdy-http2-comparison/)（SPDY，HTTP/2）

### 关于图片加载

lazy load和拼图已经是前端的基本礼仪了，毕竟带宽都是钱呀；

另外还值得注意的是webp优化，推销一下自己的文章[关于webp](http://liuyuekeng.github.io/coding/2015/11/07/about-webp.html)。
文中可以看出，webp性能优秀，但需要把它工程化搞起来还是比较麻烦的。

    1. webp图片生成有两种方式，一是在编译产出脚本上传静态资源的时候，多上一个webp的资源。
       二是第三方的图片，需要一个在线转图片格式的服务。

    2. 返回webp也有两种方式，一是页面请求，需要根据请求头的accept决定是否返回webp的版本，
       二是ajax请求，可以在客户端判断是否支持（见上面的关于webp），然后修改请求accept头。

字体文件与SVG也是常见的css拼图的替换方案，都是为了合并一些乱七八糟的小图标的请求。
这几个方案各有优缺点，但共同点都是需要工程化的支持。
编译脚本自动生成css拼图并修改css样式很方便，但是指定哪些图该拼在一起可能需要花些心思，毕竟把所有图拼在一起并不是最好的；
字体文件适用于小图标，如果大家都是方方的小图标，可以和文字混，可以自由改变颜色非常方便，但如果图标形状相差太多样式会比较难控制，
一个个做特殊处理可能陷入不可维护的深渊，贴一个小工具[fontello](http://fontello.com/)；
svg也可以在编译过程自动合并，优点在于样式（颜色，描边甚至渐变）灵活，缺点就是支持程度比较差了。[svg图标](http://qianduan.guru/2016/04/17/How-to-work-with-SVG-icons/)

另外一点需要关注的是CSS，在移动端，根据站点的PV统计，android2.3的占比其实已经很少了，
许多新的特性已经被支持，以前一些只能用图片实现的效果，完全可以由CSS样式支持。
可以参考一下《CSS揭秘》这本书（卖的好贵），介绍了一些新特性在经典场景下的应用，蛮有帮助的。

### 关于性能统计

没有性能统计，性能优化也就无从谈起。
从很久以前就开始有各种打点的性能统计工具，各个大公司也都有自己的一套日志系统。
那么除了这些白屏时间，首屏时间，资源加载，还有一些东西值得注意。

performance timing api 在移动端支持有限，样本局限导致基本没办法用来做一个基准的参考。
但相对地可以观察某个阶段是否造成额外的耗时。
比如，不必要的重定向请求造成耗时，可以考虑永久重定向；
通过secureConnectionStart来统计SSL会话的重用率；
通过首字节到达时间来衡量，是否服务器生成页面耗时过长需要拆分，甚至是否需要做静态化处理；
贴一下api的文档 [还是mozilla的文档漂亮](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming)

单页应用的性能统计会稍微有一点区别，再贴一下自己的文章[关于Angular性能监控](http://liuyuekeng.github.io/coding/2016/03/28/about-Angular-performance-monitoring.html)

### 关于数据拆分

如上面所说，如果首字节到达时间时间不可接受，可以考虑做拆分。
毕竟手机屏幕不大，能装下的信息其实并不多，把首屏所需的数据单独拆出来渲染。
剩下的数据拆成接口后续再请求。

如果页面数据接口访问时间过长，有可能是数据粒度太大，
思路是一样的，首屏数据优先，其他数据也要做分片和懒加载。
那些数据应该切割，那些数据要放在一个接口里，合适的粒度是需要花很多功夫来寻找的。
另一种可能是高耗时的查询，除了后端做优化之外，前端也应该考虑做接口缓存，避免这种情况发生。

### 删代码

这是一件很容易被忽视的事情，经常会看到代码中废弃的逻辑，重复供能的组件，无用的样式。
如果所有人都只往代码库中添加代码，却没有人去清理它们，无论代码写的多好，最终都会变得不可维护。
减少依赖，删除冗余，保持代码库的整洁能有效缩减代码体积。这项工作带来性能上的收益几乎没有，
可能成功缩减30%的代码体积只能带来区区几毫秒的改进，但在开发效率上会有很大的帮助

### 关于预加载方案

//TODO
