---
layout: post
title:  "《白帽子讲web安全》"
date:   2015-11-1 23:38:00
categories: 书评
---

##写在前面

安全的问题是最严肃的问题，但往往却是最受忽略的问题。
在这里我讲的不是普通用户，而是我们所谓的工程师。

*相比起来，我们对安全应该负更大的责任*

记得我刚入职不久，就收到公司安全部门的一个工单，说我页面下面有一个XSS漏洞。
看了一下，原因是拼接url的时候使用了一个$_GET参数。
我当时比较吃惊，原来自己写码的时候一丁点安全意识都没有，完全没有考虑过这回事，非常惭愧。

另一个事情是最近爆出的一个漏洞，其实算是一个后门被别人找出来了。
发生这种事情只能说是情理之中，安全工程中最可怕的莫过于侥幸心理。

##客户端脚本安全

####XSS（跨站脚本攻击）
如果别的网站的代码能跑到你的页面下执行，那么他基本什么都能干了。

说白了XSS漏洞的形成无非就是被插入了恶意的代码。
攻击者的想象力确实令人佩服，url，input，css等等任何地方都能藏代码，因此形成的原因复杂多样。

但最终解决的方案无非是转码，应该说是在*正确*的地方使用*正确*的转码。

书里把XSS攻击分成下面三类

* 反射型XSS

在URL参数中藏代码，一般需要让用户来点击一个藏着恶意代码的链接。
当链接中的恶意代码被渲染到页面中，给执行的时候，攻击者就达到了目的。

* 存储型XSS

恶意代码就藏在页面中，用户正常访问的时候就可能执行这一段代码。
比如在上传博文的时候夹上脚本。

* DOM Based XSS

修改DOM节点，增加事件等等来执行恶意脚本，其实感觉算是反射型的一种吧。

***

一旦脚本顺利被页面执行，就可以做好多危险的事情。

* 可以用来拿cookie做cookie劫持，绕过登陆环节
* 构造POST，GET请求，在用户不知道的情况下做各种操作。
    模拟用户进行增删改查，盗取用户信息内容，发到攻击者的服务器
* 跳弹窗钓鱼
* 判断用户浏览器特性，扫描用户安装了哪些插件。
    利用浏览器与插件的漏洞完成后续攻击
* 甚至形成蠕虫传播。

一般来说，用户输入都会经过转义和校验。
但正如前面所说，防御XSS并不是简单粗暴的转义就能够完事儿的
因为XSS是跟环境语义紧密相关的，可以说没有统一的解决方案。
不同的位置需要不同的策略对待，否则这些校验往往会被攻击者绕过。

攻击者会利用编码绕过转义，
利用事件，哈希，外部脚本绕过长度限制，
利用base标签进行资源劫持，
利用window.name跨页面传递数据，还有像flash之类危险的东西。。。

***

* 设置保存登陆信息的cookie使用HTTPOnly，这样JS就不能获取到这个cookie了。
    这实际上只能防御cookie劫持相关的攻击。
* 服务端与前端进行相同的白名单输入检查，当然输入检查同样不能解决所有问题。
    因为用户提交数据的时候还没到HTML渲染这一步，所以XSS过滤在这个时候并不能理解语境，
    有可能误杀一些正常的输入
* 输出检查就是在把用户数据输出到HTML页面的时候，进行编码，防止数据被当成代码执行。
编码必须被正确使用，否则没有意义。

输出到HTML标签中时使用HtmlEncode，防止被插入script或者图片等能产生脚本执行的东西，
输出到HTML属性中的时候也需要做同样的事情。

输出到script标签中需要进行javascriptEncode，并且保证变量输出在引号中。
被encode的变量没办法跳出引号的区域，保证安全性。
（其实我一直反感用PHP生成JS代码，最好能不用就不用，听起来就容易出问题）

在css中输出，有cssEncode的库可以将css输入编码成十六进制。
但和上一条一样，最好就不要让用户控制css代码。

在地址栏中输出当然是要使用urlEncode啦，但往往被忽视的是变量输入是一整个url的情况。
这时候协议头不能用urlEncode，有的攻击者会利用一些伪协议来执行代码
（javascript，vbscript，dataURI等）这时候需要先检查是不是http头，没有就强制加上，防御伪协议XSS攻击

富文本则需要使用*白名单*，只允许a，img，div之类安全的标签，禁用事件，禁用CSS

DOM Based XSS是一种比较特殊的情况，大概也是把它单独拆出来的原因了。
它是通过JS输出数据到HTML中，而JS代码是依赖用户数据生成，这时候需要两层编码。
首先变量输入到js代码中需要执行一次javascriptEncode，
而js往HTML中写入的时候要再做一次HTMLEncode。才能保证写入的安全。

XSS最烦的地方就是能产生漏洞的地方太tm多了，一旦有一个点没做好，就前功尽弃。

####CSRF跨站点请求伪造

诱导用户去访问一个页面，这时候页面发出一个请求，就以用户身份在第三方站点执行了一个操作。

CSRF成功一个原因是用户的cookie被发送了，这与浏览器的cookie策略有关。
还有一个特殊的HTTP头，P3P，可以让浏览器不再拦截第三方cookie发送。

防御CSRF可以用下面的各种方式

* 验证码，PM不会喜欢这种手段的，确实体验也不好
* refer检查，有的页面没有refer，比如HTTPS跳到HTTP的请求，或各种奇怪的设置
* Anti CSRF Token，生成一个随机Toke，放在session中，表单提交的时候也要加上token。
    服务器接到表单提交的时候，验证token与session中的token是否一致。
    这样的方式重点在于保证token不会被泄露。
    首先token最好藏在表单中，url中容易通过refer等渠道泄露，
    其次如果站点上有其他XSS漏洞，那么token就形同虚设了

####点击劫持
点击劫持给我的感觉像是一种耍杂技式的攻击方式，不得不说很有创意。

* 透明iframe，用透明iframe盖在最上层，通过调整iframe的位置，诱导用户不知不觉完成一些操作
* flash点击劫持，通过flash小游戏之类的形式，诱导用户进行复杂的操作，
* 图片覆盖攻击，图片可以伪装成页面的一部分，链接，按钮，logo等。
    如果img标签可以被设定style属性，就有可能出现这种威胁
* 拖拽劫持，拖拽事件是一个相对较新的事件，他相比点击更加危险，
    因为拖拽事件有的是可以跨窗口的。

有一个HTTP头叫X-Frame-Option，可以限制frame的加载，可以进行防御。

####HTML5安全

新标签和新设计的引入带来了新的问题，同时也带来了新的解决方案

先说问题

* 比如XSS过滤的时候如果是用的黑名单，有可能不会覆盖到新增标签如video，audio之类的造成跨站脚本执行。
* 在比如通过canvas可以操作图片对象，有可能被用来破解验证码。
* 跨域资源请求Access-Control-Allow-Origin。如果设成\*，那就真是日了狗了。
    我确实在公司见过把这个头设成\*的，善意提醒后人家也说改不了，不知道有多少个源在用。。。
* postMessage跨窗口传递消息，这是一个突破沙盒的东西，显而易见很容易出问题，
    用的时候要万分小心。必要时候验证url，并对接受的消息做安全检查
* web storage是一个藏代码的新地方，需要注意

新的解决方案

* iframe可以设置allow-script属性限制脚本的执行，算是一件好事
* a标签可以设置noreferrer属性，跳转不带refer
